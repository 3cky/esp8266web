/*********************************************************************
 *
 *    Dynamic Variable Parser Library
 *
 ********************************************************************/
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;

namespace Allchip
{

    public class DynamicVariableParser
    {
        UInt32 offSetCounter = 0;
		UInt32 parseItrtn=0;
		UInt32 tempFileRcrdLen=0;
		
        #region Fields
        private List<DynamicVariable> vars;
        private Regex parser = new Regex(@"~([^~]{0,127})~");
//        private Regex parsern = new Regex(@"([\w]{0,40}:|[\w]{0,40}:)");
        // private Regex parser = new Regex(@"~([ \w]{1,40}:[\w\.-\\/]{1,60}|[\w]{1,40}(\([\w,\ ]*\))?)~");
        // https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F
        private ASCIIEncoding ascii = new ASCIIEncoding();
        private String projectDir;
        #endregion

        #region String Constants
        const string HTTPPRINT_H_HEADER = 
            "/**************************************************************\r\n" +
            " !!! This file is automatically generated by the PVFS Utility !!!\r\n" +
            " * ALL MODIFICATIONS WILL BE OVERWRITTEN BY THE PVFS GENERATOR\r\n" +
            " *-------------------------------------------------------------\r\n" +
            " * webcallbacks.c\r\n" +
            " * Provides callbacks and resolution for user\'s custom\r\n" +
            " * WEB-HTTP Application.\r\n" +
            " **************************************************************/\r\n\r\n" +
            "#include \"webcallbacks.h\"\r\n\r\n"; 
        const string HTTPPRINT_H_MIDDLE =
            "\r\nLOCAL void ICACHE_FLASH_ATTR web_callback(DWORD callbackID)\r\n" +
            "{\r\n" +
            "  switch(callbackID) {\r\n";
        const string HTTPPRINT_H_FOOTER =
            "\tdefault:\r\n" +
            "\t\t// Output notification for undefined values\r\n" +
            "\t\ttcp_put(\"CallbackID not defined!\");\r\n" +
            "  };\r\n\r\n" +
            "  return;\r\n" +
            "}\r\n\r\n";
        #endregion

        #region Constructor
        public DynamicVariableParser(String path)
        {
                        this.projectDir = path;
                        vars = new List<DynamicVariable>();
/*            
                        // Read previous index file if it exists.
                        try
                        {
                            if (File.Exists(projectDir + "webcallbackids.idx"))
                            {
                                StreamReader fin = new StreamReader(projectDir + "webcallbackids.idx");
                                String s = fin.ReadLine();

                                // Ignore old PVFS2.0 HTTPPrint.idx files
                                if (!s.Contains("|"))
                                {
                                    while (s != null)
                                    {
                                        DynamicVariable dv = new DynamicVariable(s);
                                        vars.Add(dv);
                                        s = fin.ReadLine();
                                    }
                                }
                                fin.Close();
                            }
                        }
                        catch
                        {
                            // do nothing...just won't have old index information
                        }
 */
        }
        #endregion

        /// <summary>
        /// Parses and indexes a file for dynamic variables
        /// </summary>
        /// <param name="file">The PVFSFileRecord to parse</param>
        /// <returns>An PVFSFileRecord of indexes, or null if no variables were found</returns>
        public PVFSFileRecord Parse(PVFSFileRecord file)
        {
            //return null;
            byte[] idxData = new byte[0];
			UInt32 dynVarCntr=0;


            MatchCollection matches = parser.Matches(ascii.GetString(file.data));
            foreach(Match m in matches)
            {

                int i = GetIndex(m.Value.Replace("~", "")); // .Replace(" ", "")

                Array.Resize(ref idxData, idxData.Length + 8);                
/*              idxData[idxData.Length - 8] = (byte)m.Index;
                idxData[idxData.Length - 7] = (byte)(m.Index >> 8);
                idxData[idxData.Length - 6] = (byte)(m.Index >> 16);
                idxData[idxData.Length - 5] = (byte)(m.Index >> 24);
                idxData[idxData.Length - 4] = (byte)i;
                idxData[idxData.Length - 3] = (byte)(i >> 8);
                idxData[idxData.Length - 2] = (byte)(i >> 16);
                idxData[idxData.Length - 1] = (byte)(i >> 24);


				Array.Resize(ref file.dynVarOffsetAndIndexID, file.dynVarOffsetAndIndexID.Length + 8); 

				file.dynVarOffsetAndIndexID[file.dynVarOffsetAndIndexID.Length - 1] = (byte)(i >> 24);
   			    file.dynVarOffsetAndIndexID[file.dynVarOffsetAndIndexID.Length - 2] = (byte)(i >> 16);
   			    file.dynVarOffsetAndIndexID[file.dynVarOffsetAndIndexID.Length - 3] = (byte)(i >> 8);
   			    file.dynVarOffsetAndIndexID[file.dynVarOffsetAndIndexID.Length - 4] = ((byte)i);

                
				file.dynVarOffsetAndIndexID[file.dynVarOffsetAndIndexID.Length - 5] = (byte)(m.Index >> 24);
				file.dynVarOffsetAndIndexID[file.dynVarOffsetAndIndexID.Length - 6] = (byte)(m.Index >> 16);
				file.dynVarOffsetAndIndexID[file.dynVarOffsetAndIndexID.Length - 7] = (byte)(m.Index >> 8);
				file.dynVarOffsetAndIndexID[file.dynVarOffsetAndIndexID.Length - 8] = (byte)m.Index;
  */              
				file.dynVarCntr = ++dynVarCntr;
//                offSetCounter = offSetCounter + 8;
			
            }
/*			
			if(parseItrtn == (UInt32)0x0)
			{
				file.fileRecordOffset = (UInt32)0x0;
				offSetCounter = (UInt32)0x0;
			}
			else
			{
				file.fileRecordOffset=tempFileRcrdLen;
			}

            file.fileRecordLength = 4 // 4 bytes for file record length itself
                                    + 2; //To store the hasIndex/isZipped flag
									//+(UInt32)file.FileName.Length 
									+ file.dynVarCntr*8; // *4
			
			tempFileRcrdLen += file.fileRecordLength;
*/
			parseItrtn++;
				

			// Determine if any matches were made
            if (idxData.Length == 0)
                return null;
            else
            {
                // Set up new file record
                PVFSFileRecord idxFile = new PVFSFileRecord();
                idxFile.FileName = "";
                idxFile.fileDate = file.fileDate;
                idxFile.isIndex = true;
                idxFile.data = idxData;
                return idxFile;
            }
        }

        /// <summary>
        /// Writes out if necessary
        /// </summary>
        /// <returns>TRUE if the files were written, FALSE if no changes are needed</returns>
        public bool WriteIndices()
        {
            // Determine if an update is necessary
            bool isChanged = false;
            foreach (DynamicVariable dv in vars)
            {
                if ((dv.WasUsed && dv.Count == 0) ||
                    (!dv.WasUsed && dv.Count != 0))
                {
                    isChanged = true;
                    break;
                }
            }
            if (!isChanged)
                return false;

            // Write out HTTPPrint.idx
            StreamWriter fout = new StreamWriter(projectDir + "web_vars.txt", false);
            foreach (DynamicVariable dv in vars)
            {
                fout.WriteLine(dv.Name);
            }
            fout.Flush();
            fout.Close();
/*
            // Begin writing HTTPPrint.h
            fout = new StreamWriter(projectDir + "webcallbacks.c", false);
            fout.Write(HTTPPRINT_H_HEADER);

            // Write the prototypes

            // Write the function itself
            fout.Write(HTTPPRINT_H_MIDDLE);
            int index = 0;
            foreach (DynamicVariable dv in vars)
            {
                if (dv.Count == 0)
                {
                    index++;
                    continue;
                }

                fout.Write("\tcase 0x" + Convert.ToString(index++, 16).PadLeft(8, '0') + ":\r\n");

                // Write the actual case statement
                if(dv.Name.StartsWith("inc:"))
                {
                    fout.Write("\t\tweb_inc_file(); // file:`" + dv.Name.Substring(4) + "`\r\n\t\tbreak;\r\n");
                }
                else if(dv.Name.StartsWith("tcp:"))
                {
                    fout.Write("\t\ttcp_puts(" + dv.Name.Substring(4) + ");\r\n\t\tbreak;\r\n");
                }
                else if (dv.Name.StartsWith("com:"))
                {
                    fout.Write("\t\tcom_puts(" + dv.Name.Substring(4) + ");\r\n\t\tbreak;\r\n");
                }
                else if (dv.Name.Length == 0)
                {
                    fout.Write("\t\ttcp_put('~');\r\n\t\tbreak;\r\n");
                }
                else
                {
                    fout.Write("\t\t" + dv.Name + ";\r\n\t\tbreak;\r\n");
                }
            }

            // Write the footer part
            fout.Write(HTTPPRINT_H_FOOTER);
            fout.Flush();
            fout.Close();
            */
            return true;
        }

        #region Private Methods
        /// <summary>
        /// Finds the index of a dynamic variable, or creates a new one
        /// </summary>
        /// <param name="name"></param>
        /// <returns>The index of the dynamic variable</returns>
        private int GetIndex(String name)
        {
            // Search for the dynamic variable
            DynamicVariable dv = new DynamicVariable(name);
            int i = vars.IndexOf(dv);
            
            // If not found, add a new one
            if (i == -1)
            {
                vars.Add(dv);
                i = vars.Count - 1;
            }

            // Mark as used and return the index
            vars[i].Count++;
            return i;
        }
        #endregion

    }

    public class DynamicVariable
    {
        #region Fields
        private String name;
        private bool wasUsed;
        private int count;
        #endregion

        #region Properties
        /// <summary>
        /// Gets or sets the name of this DynamicVariable
        /// </summary>
        public String Name
        {
            get { return this.name; }
            set { this.name = value; }
        }

       /// <summary>
        /// Indicates if this specific instance was previously used
        /// </summary>
        public bool WasUsed
        {
            get { return this.wasUsed; }
            set { this.wasUsed = value; }
        }

        /// <summary>
        /// Indicates how many times this instance is used
        /// </summary>
        public int Count
        {
            get { return this.count; }
            set { this.count = value; }
        }

        private long _offsetCntr = 0;
        public long offsetCntr
        {
            get { return _offsetCntr; }
            set { _offsetCntr = value; }
        }
        #endregion

        #region Constructor
        public DynamicVariable(String name)
        {
//            this.wasUsed = name.StartsWith("+");
            this.name = name.Trim(); //  Regex.Replace(name, @"[\ \+]", "");
            this.count = 0;
        }
        #endregion

        public override bool Equals(object obj)
        {
            if (obj is DynamicVariable)
                return ((DynamicVariable)obj).Name == this.name;
            else
                return false;
        }

        public override int GetHashCode()
        {
            return this.name.GetHashCode();
        }
    }

}
